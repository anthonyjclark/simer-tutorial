[
  {
    "objectID": "demos/1-analytical.html",
    "href": "demos/1-analytical.html",
    "title": "Demo 1: Analytical Models",
    "section": "",
    "text": "Let’s start with the following problem statement:\n\nWe want to evolve an autonomous wheeled mobile robot (WMR) to maximize the distance traveled in a fixed amount of time.\n\nBase demo\nchassisPosition = initialPosition + angularVelocity * wheelRadius * time;\n\n    \n\n\nimport { Player } from '../_lib/Player/dist/player.js';\nimport { WMRSimulator, WMR2DMode } from  '../_lib/WMR2D/dist/wmr2d.js';\n\nuiTimeEnd = 16.0;\nuiTimeStep = 0.1;\n\nwmr1 = new WMRSimulator( 'wmr-canvas1', WMR2DMode.ClosedForm );\nplayer1 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr1.step(time), () =&gt; wmr1.reset() );\nplayer1.create();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith wall (what is the equation now?); can figure it out with some work.\n\n    \n\n\nwmr2 = new WMRSimulator( 'wmr-canvas2', WMR2DMode.ClosedForm, { addWall: true } );\nplayer2 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr2.step(time), () =&gt; wmr2.reset() );\nplayer2.create();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith step; probably cannot get a reasonable result.\n\n    \n\n\nwmr3 = new WMRSimulator( 'wmr-canvas3', WMR2DMode.ClosedForm, { addWall: true, addStep: true } );\nplayer3 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr3.step(time), () =&gt; wmr3.reset() );\nplayer3.create();",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 1: Analytical Models"
    ]
  },
  {
    "objectID": "demos/5-full-example.html",
    "href": "demos/5-full-example.html",
    "title": "Demo 5: Full Example",
    "section": "",
    "text": "Test\nsteps (maybe show comparison chart for several physics engines)\n\ninstall software\ncreate “world” (and collision space)\ncreate “robot” (bodies and geometries/shapes; constraints/joints)",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 5: Full Example"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SimER Tutorial",
    "section": "",
    "text": "ALIFE has a long history with virtual creatures, and the Virtual Creatures Competition (VCC) has been a mainstay at the conference for a decade now. Enabling research in this area are many unique, and often single-purpose, simulation environments. The variety of simulation options is useful for creating finely tuned experiments but makes it difficult for newcomers to the field to determine which simulation environment is appropriate for their particular problem.\nALIFE has also hosted several tutorials relating to this work, for example,\nThis tutorial, will provide a broader look at the paradigms and tools used in the field of evolutionary robotics (and in ALIFE more generally). Specifically, we will discuss the use of several different simulation methods and tools, including:\nWe will also discuss visualization techniques.\nOf course, covering this wide range of topics necessarily means that we will not be able to go into great depth on all of them. Instead we will pay special attention to the use of physical simulation engines as they provide the widest range of possibilities with respect to creating and evolving virtual creatures. Staying with the theme of ALIFE 2024 we will share our experiences with “weird and wacky” results (and how to avoid them if they are not what you are looking for)."
  },
  {
    "objectID": "index.html#tutorial-agenda",
    "href": "index.html#tutorial-agenda",
    "title": "SimER Tutorial",
    "section": "Tutorial Agenda",
    "text": "Tutorial Agenda\n\nPresentation\nTutorial Demos\nExploration"
  },
  {
    "objectID": "index.html#logistics",
    "href": "index.html#logistics",
    "title": "SimER Tutorial",
    "section": "Logistics",
    "text": "Logistics\n\nFriday, 26 July\nParallel session 10: 15:00 - 16:40\nRoom: TBD\nQuestion and Answers: TBD (Google Sheet)"
  },
  {
    "objectID": "index.html#audience",
    "href": "index.html#audience",
    "title": "SimER Tutorial",
    "section": "Audience",
    "text": "Audience\nOur primary target audience members are researchers new to the field of ALIFE and evolutionary robotics. We are also happy to have more experienced researchers looking for information to share with their students."
  },
  {
    "objectID": "resources/tools.html",
    "href": "resources/tools.html",
    "title": "Tools",
    "section": "",
    "text": "Simulation plays a vital role in optimization and in understanding evolutionary dynamics. SimER focuses on rigid-body dynamics, but we’ve listed a few related ideas below as well.\nCreating a simulation is called “modeling.” In robotics, modeling is used for simulation, state estimation, prediction, and model-based algorithms (e.g., model predictive control, model-based reinforcement learning).\nBroadly, we can list the following forms of simulation as it relates to evolutionary robotics (ER)\nOften, an increase in accuracy comes at the cost of an increase in complexity and compute time. Analytical simulations are often only useful for toy problems (i.e., they are not even expressive enough to simulate a double pendulum system). Numerical systems are much broader—in some sense, they encapsulate rigid-body and soft-body dynamics—but they are often slower and less powerful compared to rigid-body and soft-body simulators. For example, a nonholonomic system cannot be described by a closed-form solution. In this case, a numerical or physical simulation is required.\nHere are things to consider when selecting your simulation tool:",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#robot-simulators",
    "href": "resources/tools.html#robot-simulators",
    "title": "Tools",
    "section": "Robot Simulators",
    "text": "Robot Simulators\n\nGazebo\nCoppeliaSim (V-REP replacement)\nWebots\nIsaac Sim\nVortex Studio\nDrake\nRoboDK\nMARS\nSimscape Multibody\nRaiSim",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#game-engines",
    "href": "resources/tools.html#game-engines",
    "title": "Tools",
    "section": "Game Engines",
    "text": "Game Engines\n\nUnreal Engine\nUnity\nGodot Engine\nBevy",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#physics-engines",
    "href": "resources/tools.html#physics-engines",
    "title": "Tools",
    "section": "Physics Engines",
    "text": "Physics Engines\n\nGame focused\n\nPhysX\nBullet\nODE\nJolt Physics\nHavok\nNewton Dynamics\nReactPhysics3D\n\nResearch/Robotics focused\n\nMuJoCo\nPROJECTCHRONO\nDART\nTPE (Trivial Physics Engine)\nRBDL\nRigidBodyDynamics.jl\nRapier",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#numerical-engines",
    "href": "resources/tools.html#numerical-engines",
    "title": "Tools",
    "section": "Numerical Engines",
    "text": "Numerical Engines\n\nGNU Octave\nSageMath\nScilab\nSimPy\nMATLAB\nWolfram Mathematica\nMaple\nDynamicalSystems.jl",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#soft-body-engines",
    "href": "resources/tools.html#soft-body-engines",
    "title": "Tools",
    "section": "Soft-Body Engines",
    "text": "Soft-Body Engines\n\nSoft Robotics Toolkit\nVoxCad\nevosoro: soft robot simulator\nDiffAqua",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#rendering-engines",
    "href": "resources/tools.html#rendering-engines",
    "title": "Tools",
    "section": "Rendering Engines",
    "text": "Rendering Engines\n\nOGRE\nIrrlicht Engine\nbgfx\nFilament\nMagnum Engine\nThree.js",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#configuration-language",
    "href": "resources/tools.html#configuration-language",
    "title": "Tools",
    "section": "Configuration Language",
    "text": "Configuration Language\n\nURDF (and Xacro)\nSDFormat\nSKEL\nCOLLADA\nSMURF\nSRDF",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#authoring-tools",
    "href": "resources/tools.html#authoring-tools",
    "title": "Tools",
    "section": "Authoring Tools",
    "text": "Authoring Tools\n\nPhobos\nOnshape-to-robot\nSolidWorks to URDF Exporter",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#physics-engine-development",
    "href": "resources/tools.html#physics-engine-development",
    "title": "Tools",
    "section": "Physics Engine Development",
    "text": "Physics Engine Development\n\nIntegration Basics\nFix Your Timestep!\nTen Minute Physics\nBox2D-Lite",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "presentation.html#format",
    "href": "presentation.html#format",
    "title": "SimER Tutorial",
    "section": "",
    "text": "This tutorial will follow a format in which:\n\nWe’ll get on the same page with respect to terminology\nLoop\n\nI’ll present for a bit\nI’ll ask you all to read through an exercise\nWe’ll have time for discussion\n\nWe’ll cover a more complete example in full",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#evolutionary-robotics",
    "href": "presentation.html#evolutionary-robotics",
    "title": "SimER Tutorial",
    "section": "",
    "text": "The use of evolutionary algorithms to explore the design space of robots and their control software.",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#research-questions",
    "href": "presentation.html#research-questions",
    "title": "SimER Tutorial",
    "section": "",
    "text": "There is a wide variety of research in evolutionary robotics, but I’ll focus on:\n\nOptimization and novelty (application-based)\nAlgorithm design (theory-based)",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#general-algorithm",
    "href": "presentation.html#general-algorithm",
    "title": "SimER Tutorial",
    "section": "",
    "text": "flowchart LR\n    Init[Initialize] --&gt; Eval[Evaluate]\n    Eval --&gt; Stop{Stop?}\n    Stop --Yes--&gt; Retn[Return]\n    Stop --No--&gt; Sele[Select]\n    Sele --&gt; Modi[Modify]\n    Modi --&gt; Comb[Combine]\n    Comb --&gt; Eval\n\n\n\n\n\n\nTODO: fix flow chart and pseudocode\npopulation = Initialize()\n\nLOOP\n  fitnesses = Evaluate(population)\n  IF Stop(fitnesses) THEN BREAK\n  selected = Select(population, fitnesses)\n  children = Modify(selected)\n  population = Combine(population, children)\n\nRETURN population\npopulation = initialize(POPULATION_SIZE)\npopulation = evaluate(population)\n\nfor generation in range(NUM_GENERATIONS):\n    if stop(population):\n        break\n\n    # Tournament selection\n    selected = select(population)\n    # Just mutation (no crossover?); maybe DE?\n    children = modify(selected)\n    children = evaluate(children)\n    # Elitism of 1?\n    population = combine(population, children)\n\nFitness = tuple[float, float]\nGenome = list[float]\nIndividual = tuple[Genome, Fitness]\nPopulation = list[Individual]\n\ndef initialize(size: int) -&gt; Population: ...\ndef evaluate(pop: Population) -&gt; Population: ...\ndef stop(pop: Population) -&gt; bool: ...\ndef select(pop: Population) -&gt; Population: ...\ndef modify(pop: Population) -&gt; Population: ...\ndef combine(pop1: Population, pop2: Population) -&gt; Population: ...",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#practical-considerations-1",
    "href": "presentation.html#practical-considerations-1",
    "title": "SimER Tutorial",
    "section": "Practical Considerations",
    "text": "Practical Considerations\n\nSimulation, feasibility, and reality gap\nComputational resources (headless, parallelism, etc.)\nManagement (analysis, visualizing, plotting, etc.)\nResearch management (tracking, reproducibility, collaboration, etc.)\nValidation on hardware\n\nMajor challenge: “reality gap”",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#parallelism",
    "href": "presentation.html#parallelism",
    "title": "SimER Tutorial",
    "section": "Parallelism",
    "text": "Parallelism\nYou’ll want to run your experiments on a compute cluster if possible.\n\nParallelize replicate experiments (different random seeds)\nParallelize across generations (if mixing populations)\nParallelize across populations (multiple population per replicate)\nParallelize across individuals (multiple individuals per population)\nParallelize across trials (multiple trials per individual)",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#parallelism-advice",
    "href": "presentation.html#parallelism-advice",
    "title": "SimER Tutorial",
    "section": "Parallelism Advice",
    "text": "Parallelism Advice\n\nPlan to use \\(N - 2\\) cores, where \\(N\\) is the number of cores available\nUse a tool like GNU Parallel at the replicate level\nUse a library like Python multiprocessing at lower levels\nConsider what you need to evaluate for early stopping when making your choices between higher and lower levels of parallelism\n\nDo you care more about the variance across replicates? Parallelize at the replicate level\nDo you care more about the performance of a single replicate? Parallelize at the individual level",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#problem-statement",
    "href": "presentation.html#problem-statement",
    "title": "SimER Tutorial",
    "section": "Problem Statement",
    "text": "Problem Statement\nObjective: maximize the distance traveled by an autonomous wheeled mobile robot (WMR) in a fixed amount of time.",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#online-demos",
    "href": "presentation.html#online-demos",
    "title": "SimER Tutorial",
    "section": "Online Demos",
    "text": "Online Demos\nStarting with Analytical Models",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#full-examples",
    "href": "presentation.html#full-examples",
    "title": "SimER Tutorial",
    "section": "Full Examples",
    "text": "Full Examples\nFull description at Full Example.",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "resources/advice.html",
    "href": "resources/advice.html",
    "title": "Advice",
    "section": "",
    "text": "statistics (replicates)\nnoise\ndeterminism\nlevels-of-abstraction\nGNU Parallel Tutorial Pueue is a command-line task management tool",
    "crumbs": [
      "Home",
      "Resources",
      "Advice"
    ]
  },
  {
    "objectID": "resources/advice.html#mixed-environments",
    "href": "resources/advice.html#mixed-environments",
    "title": "Advice",
    "section": "Mixed Environments",
    "text": "Mixed Environments\nmixing 2d and 3d - e.g., ODE and top-down map ray tracing",
    "crumbs": [
      "Home",
      "Resources",
      "Advice"
    ]
  },
  {
    "objectID": "resources/related.html",
    "href": "resources/related.html",
    "title": "Related Events",
    "section": "",
    "text": "Virtual Creatures Competition (VCC)!\nEngineering the open-ended evolution of synthetic biology\nAutomatic Design of Robot Bodies and Brains with Evolutionary Algorithms\nJAX for Scaling Up Artificial Life\nNeuroevolution\nSwissGL/GPU: tiny libraries for tiny and beautiful programs on the web",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section",
    "href": "resources/related.html#section",
    "title": "Related Events",
    "section": "",
    "text": "Virtual Creatures Competition (VCC)!\nEngineering the open-ended evolution of synthetic biology\nAutomatic Design of Robot Bodies and Brains with Evolutionary Algorithms\nJAX for Scaling Up Artificial Life\nNeuroevolution\nSwissGL/GPU: tiny libraries for tiny and beautiful programs on the web",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-1",
    "href": "resources/related.html#section-1",
    "title": "Related Events",
    "section": "2023",
    "text": "2023\n\nOpenMOLE (model exploration and validation)\nPhylogenies (how and why to track them)\nEvolving Robot Bodies and Brains in Unity\nCellular Automata\nSelf-Organizing Systems with Machine Learning",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-2",
    "href": "resources/related.html#section-2",
    "title": "Related Events",
    "section": "2022",
    "text": "2022\n\nIntroduction to Using Symbulation\nSimulating pandemics with agent-based models",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-3",
    "href": "resources/related.html#section-3",
    "title": "Related Events",
    "section": "2021",
    "text": "2021\n\nBehavioral and Cognitive Robotics, an adaptive perspective",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-4",
    "href": "resources/related.html#section-4",
    "title": "Related Events",
    "section": "2020",
    "text": "2020\n\nThe Bibites: Getting the online community involved into Alife through game development (Bibites)\nIntroduction to MABE, A tool for studying evolving systems and digital brains (MABE)\nLarge Scale Agent Based Modelling with FLAME GPU 2 (FLAME GPU 2)\nMolecular programming of swarms for ALife (MolProg)\nProgramming soft alife with SPLAT and ulam (HackSPLAT)\nVisualization Principles and Techniques for Research in ALife (ALifeVis2020)",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-5",
    "href": "resources/related.html#section-5",
    "title": "Related Events",
    "section": "2019",
    "text": "2019\n\nIntelligent Systems for Smart Cities\nIntroduction to Avida-ED",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-6",
    "href": "resources/related.html#section-6",
    "title": "Related Events",
    "section": "2018",
    "text": "2018\n\nAvida-ED\nCreate predictions with neural networks",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is the second occurrence of SimER. The first was as a workshop held at GECCO 2017. Here are the contributions from the workshop:\n\n20 years of reality gap: a few thoughts about simulators in evolutionary robotics by Jean-Baptiste Mouret and Konstantinos Chatzilygeroudis\nSimulating the evolution of soft and rigid-body robots by Sam Kriegman, Collin Cappelle, Francesco Corucci, Anton Bernatskiy, Nick Cheney, and Josh C. Bongard\nA baseline-realistic objective open-ended kinematics simulator for evolutionary robotics by Riley Konsella, Frank Chiarulli, John Peterson, and John Rieffel\n\nAnthony J. Clark received is Ph.D from Michigan State University. He is currently an Assistant Professor in the Computer Science Department at Pomona College in Claremont, California, USA and a Research Scientist at Caltech in Pasadena, California, USA. His research interests include autonomous robotics, control theory, adaptive control, and evolutionary optimization.\nJared M. Moore received is Ph.D from Michigan State University. He is currently an Associate Professor in the School of Computing and Information Systems at Grand Valley State University, Allendale, Michigan, USA. His research interests include adaptive software, autonomous robotics, and evolutionary optimization."
  },
  {
    "objectID": "presentation.html",
    "href": "presentation.html",
    "title": "SimER Tutorial",
    "section": "",
    "text": "This tutorial will follow a format in which:\n\nWe’ll get on the same page with respect to terminology\nLoop\n\nI’ll present for a bit\nI’ll ask you all to read through an exercise\nWe’ll have time for discussion\n\nWe’ll cover a more complete example in full\n\n\n\n\nThe use of evolutionary algorithms to explore the design space of robots and their control software.\n\n\n\nThere is a wide variety of research in evolutionary robotics, but I’ll focus on:\n\nOptimization and novelty (application-based)\nAlgorithm design (theory-based)\n\n\n\n\n\n\n\n\n\nflowchart LR\n    Init[Initialize] --&gt; Eval[Evaluate]\n    Eval --&gt; Stop{Stop?}\n    Stop --Yes--&gt; Retn[Return]\n    Stop --No--&gt; Sele[Select]\n    Sele --&gt; Modi[Modify]\n    Modi --&gt; Comb[Combine]\n    Comb --&gt; Eval\n\n\n\n\n\n\nTODO: fix flow chart and pseudocode\npopulation = Initialize()\n\nLOOP\n  fitnesses = Evaluate(population)\n  IF Stop(fitnesses) THEN BREAK\n  selected = Select(population, fitnesses)\n  children = Modify(selected)\n  population = Combine(population, children)\n\nRETURN population\npopulation = initialize(POPULATION_SIZE)\npopulation = evaluate(population)\n\nfor generation in range(NUM_GENERATIONS):\n    if stop(population):\n        break\n\n    # Tournament selection\n    selected = select(population)\n    # Just mutation (no crossover?); maybe DE?\n    children = modify(selected)\n    children = evaluate(children)\n    # Elitism of 1?\n    population = combine(population, children)\n\nFitness = tuple[float, float]\nGenome = list[float]\nIndividual = tuple[Genome, Fitness]\nPopulation = list[Individual]\n\ndef initialize(size: int) -&gt; Population: ...\ndef evaluate(pop: Population) -&gt; Population: ...\ndef stop(pop: Population) -&gt; bool: ...\ndef select(pop: Population) -&gt; Population: ...\ndef modify(pop: Population) -&gt; Population: ...\ndef combine(pop1: Population, pop2: Population) -&gt; Population: ...",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#simulation",
    "href": "presentation.html#simulation",
    "title": "SimER Tutorial",
    "section": "Simulation",
    "text": "Simulation\n\nFollow a gradient of feasibility to provide a better “gradient”\nScale your parameters for numerical stability\n…",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#experiment-management",
    "href": "presentation.html#experiment-management",
    "title": "SimER Tutorial",
    "section": "Experiment Management",
    "text": "Experiment Management\n\nwandb, for example",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "demos/2-numerical.html",
    "href": "demos/2-numerical.html",
    "title": "Demo 2: Numerical Models",
    "section": "",
    "text": "Moving to a numerical version. It is easy to handle the wall now.\n\n    \n\n\nimport { Player } from '../_lib/Player/dist/player.js';\nimport { WMRSimulator, WMR2DMode } from  '../_lib/WMR2D/dist/wmr2d.js';\n\nuiTimeEnd = 16.0;\nuiTimeStep = 0.1;\n\nwmr1 = new WMRSimulator( 'wmr-canvas1', WMR2DMode.Numerical );\nplayer1 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr1.step(time), () =&gt; wmr1.reset() );\nplayer1.create();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Closed-form solution\nchassisPosition = initialPosition + angularVelocity * wheelRadius * time;\n\n// Numerical solution\nchassisPosition += angularVelocity * wheelRadius * timeStep;\nAlso means we can now control the distance easier.\nwmr = new WMR2D( { addWall: true } );\n\nlet prevTime = 0.0;\nlet time = 0.0;\n\nconst controlPeriod = 0.1;\nlet controlLastUpdate = 0.0;\n\nwhile ( true ) {\n\n  if ( ! prevTime ) prevTime = now;\n  const dt = ( now - prevTime ) / 1000.0;\n  prevTime = now;\n\n  time += dt;\n\n  // Simulate\n  wmr.updatePositionNumerical( dt );\n\n  // Draw\n  wmr.render();\n\n  // Update control\n  if ( time &gt;= controlLastUpdate ) {\n\n    const dist = wmr.getDistanceToWall();\n    const speed = Math.min( 3.0, 20 * ( dist - 2.5 ) / 20.0 );\n    wmr.setWheelAngularVelocity( speed );\n\n    controlLastUpdate += controlPeriod;\n\n  }\n\n}\n\n    \n\n\nwmr2 = new WMRSimulator( 'wmr-canvas2', WMR2DMode.Numerical, { addWall: true } );\nplayer2 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr2.step(time), () =&gt; wmr2.reset() );\nplayer2.create();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat if we want to add an incline?\nCan do, but the equations are more complex.\nAgain, how about a step? How about an incline and a step?\n\n    \n\n\nwmr3 = new WMRSimulator( 'wmr-canvas3', WMR2DMode.Numerical, { addWall: true, addStep: true } );\nplayer3 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr3.step(time), () =&gt; wmr3.reset() );\nplayer3.create();",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 2: Numerical Models"
    ]
  },
  {
    "objectID": "demos/3-adding-collisions.html",
    "href": "demos/3-adding-collisions.html",
    "title": "Demo 3: Adding Collisions",
    "section": "",
    "text": "mutable number = 0;\n\n\n\n\n\n\n\nmutable number += 1;",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 3: Adding Collisions"
    ]
  },
  {
    "objectID": "demos/4-rigid-body.html",
    "href": "demos/4-rigid-body.html",
    "title": "Demo 4: Rigid Body Models",
    "section": "",
    "text": "import { Player } from '../_lib/Player/dist/player.js';\nimport { WMRSimulator, WMR2DMode } from  '../_lib/WMR2D/dist/wmr2d.js';\n\nuiTimeEnd = 16.0;\nuiTimeStep = 0.1;\n\nwmr1 = new WMRSimulator( 'wmr-canvas1', WMR2DMode.PhysicsEngine, { addWall: true, addStep: true} );\nplayer1 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr1.step(time), () =&gt; wmr1.reset() );\nplayer1.create();",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 4: Rigid Body Models"
    ]
  }
]