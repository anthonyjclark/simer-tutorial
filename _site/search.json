[
  {
    "objectID": "demos/1-analytical.html",
    "href": "demos/1-analytical.html",
    "title": "Demo 1: Analytical Models",
    "section": "",
    "text": "Let’s start with the following problem statement:",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 1: Analytical Models"
    ]
  },
  {
    "objectID": "demos/1-analytical.html#analytical-model",
    "href": "demos/1-analytical.html#analytical-model",
    "title": "Demo 1: Analytical Models",
    "section": "Analytical Model",
    "text": "Analytical Model\nWe’ll start with the simplest form of simulation: an analytical model for the WMR (also known as a closed-form solution).\nFor a WMR (like the one in the animation below), we can model the motion of the robot using the following equation:\n\\[\nx_t = x_0 + \\omega r t\n\\tag{1}\\]\nwhere \\(x_t\\) is the position of the robot at time \\(t\\), \\(x_0\\) is the initial position of the robot, \\(\\omega\\) is the angular velocity of the robot’s wheels, and \\(r\\) is the radius of its wheels. This maps directly to the following code:\nchassisPosition = initialPosition + angularVelocity * wheelRadius * time;\nA full simulation might look like:\ninitialPosition = 0;\nchassisPosition = initialPosition;\n\nangularVelocity = 1;\nwheelRadius = 1;\n\nfunction simulate( time: number ) {\n    // x = v t = x0 + ω r t\n    chassisPosition = initialPosition + angularVelocity * wheelRadius * time;\n}",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 1: Analytical Models"
    ]
  },
  {
    "objectID": "demos/1-analytical.html#visualization",
    "href": "demos/1-analytical.html#visualization",
    "title": "Demo 1: Analytical Models",
    "section": "Visualization",
    "text": "Visualization\nVisualizing the WMR’s motion is not necessary for evolutionary robotics, but it can help us understand behaviors and debug our models. It is useful to completely decouple simulation from visualization. Here is a snippet showing how the visualizations below are created:\ninitialPosition = 0;\nchassisPosition = initialPosition;\n\nangularVelocity = 1;\nwheelRadius = 1;\n\nwheelChassisOffset = 1;\nwheelPositionFront = wheelChassisOffset;\nwheelPositionRear = -wheelChassisOffset;\n\nwheelAngleFront = 0;\nwheelAngleRear = 0;\n\nfunction simulate( time: number ) {\n\n    // p = v t = ω r t\n    chassisPosition = initialPosition + angularVelocity * wheelRadius * time;\n\n    wheelPositionFront = chassisPosition + wheelChassisOffset;\n    wheelPositionRear = chassisPosition - wheelChassisOffset;\n\n    wheelAngleFront = angularVelocity * time;\n    wheelAngleRear = angularVelocity * time;\n\n}\n\nwhile ( !done ) {\n\n    time = getTime();\n    simulate( time );\n    render();\n\n}",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 1: Analytical Models"
    ]
  },
  {
    "objectID": "demos/1-analytical.html#analytical-model-simulation",
    "href": "demos/1-analytical.html#analytical-model-simulation",
    "title": "Demo 1: Analytical Models",
    "section": "Analytical Model Simulation",
    "text": "Analytical Model Simulation\nThe following is a simple simulation of a WMR using the analytical model. The robot moves in a straight line without any obstacles. It “collides” with the edge of the simulation environment by adding a simple condition check in the simulation loop that limits the chassis’s position but not he wheel rotations.\n\n    \n\n\nimport { Player } from '../_lib/Player/dist/player.js';\nimport { WMRSimulator, WMR2DMode } from  '../_lib/WMR2D/dist/wmr2d.js';\n\nuiTimeEnd = 16.0;\nuiTimeStep = 0.1;\n\nwmr1 = new WMRSimulator( 'wmr-canvas1', WMR2DMode.Analytical );\nplayer1 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr1.step(time), () =&gt; wmr1.reset() );\nplayer1.create();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat if we want to add an additional obstacle? For example, a wall partway through the environment. What happens when we simulate the WMR now?\n\n    \n\n\nwmr2 = new WMRSimulator( 'wmr-canvas2', WMR2DMode.Analytical, { addWall: true } );\nplayer2 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr2.step(time), () =&gt; wmr2.reset() );\nplayer2.create();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat happens when we add a wall?\n\n\n\n\n\nAdding simple collisions is pretty easy, even with the analytical model. We just add an additional check in the update loop.\nif ( distanceToWall &gt; 0 && distanceToEdge &gt; 0 ) {\n\n    this.chassisPosition += this.angularVelocity * this.wheelRadius * this.timeStep;\n\n}",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 1: Analytical Models"
    ]
  },
  {
    "objectID": "demos/1-analytical.html#dynamic-control",
    "href": "demos/1-analytical.html#dynamic-control",
    "title": "Demo 1: Analytical Models",
    "section": "Dynamic Control",
    "text": "Dynamic Control\nWhat if we want to add dynamic control to the WMR? For example, we want the WMR to stop in front of the wall without hitting it? Something like the following:\n\\[\n\\omega = \\max( -\\Omega, \\min( \\Omega, m d + b)\n\\tag{2}\\]\nwhere \\(\\Omega\\) is the maximum angular velocity, \\(m\\) is the proportional gain, \\(d\\) is the distance to the wall, and \\(b\\) is the control bias.\nTake a second to understand the equation above.\n\n\n\n\n\n\nWhat does the equation mean?\n\n\n\n\n\nThe equation above is a simple proportional controller. It calculates the angular velocity of the robot based on the distance to the wall. The robot will stop when it reaches some distance from the wall based on the values of \\(m\\) and \\(b\\).\n\n\n\nNow, consider how we might add this equation to the simulation. Here is the simulate function from above:\nfunction simulate( time: number ) {\n    // x = v t = x0 + ω r t\n    chassisPosition = initialPosition + angularVelocity * wheelRadius * time;\n}\nHow can we change the chassisPosition based on a dynamic value for angularVelocity? You can probably think of some ways to restructure the code, but essentially, we can no longer compute the current position based solely on the time. Instead, we need to know the time, the current position, and the current angular velocity.\nThis dependency on the current position is a problem for the analytical model.\n\n    \n\n\nwmr3 = new WMRSimulator( 'wmr-canvas3', WMR2DMode.Analytical, { addWall: true } );\nplayer3 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr3.step(time), () =&gt; wmr3.reset() );\nplayer3.create();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe simulation above does not stop in front of the wall, because we have better methods for handling this scenario. We will explore these methods in the next demo.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 1: Analytical Models"
    ]
  },
  {
    "objectID": "demos/4-full-example.html",
    "href": "demos/4-full-example.html",
    "title": "Demo 4: Full Example",
    "section": "",
    "text": "We’ll now look at a full evolutionary robotics example. Here are the steps:",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 4: Full Example"
    ]
  },
  {
    "objectID": "demos/4-full-example.html#setup",
    "href": "demos/4-full-example.html#setup",
    "title": "Demo 4: Full Example",
    "section": "Setup",
    "text": "Setup\nI am using an HPC linux server with Lmod (used for environment management) and Slurm (for workload management). Though these instructions will work pretty broadly.\nI use Miniforge to manage my software installations. So, here is my process:\n# Install or activate Miniforge\nmodule load miniforge3\n\n# Create a new environment\nmamba create --name simer\n\n# Install necessary packages\nmamba install pybox2d ipython pandas enlighten jupyter seaborn plotly\n\n# Save the environment for reproducibility (create both)\nconda env export --from-history &gt; cross-platform.yml\nconda list --explicit &gt; spec-file.txt\n\n# Create a directory for code (and a separate for data if needed)\nmkdir -p ~/simer-tutorial\ncd ~/simer-tutorial\nOnce the directory is created, I typically edit code using VSCode with the Remote - SSH extension.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 4: Full Example"
    ]
  },
  {
    "objectID": "demos/4-full-example.html#simulation",
    "href": "demos/4-full-example.html#simulation",
    "title": "Demo 4: Full Example",
    "section": "Simulation",
    "text": "Simulation\nMy WMR simulation, written in Python, largely follows the version from demos 1-3. The key is that the simulation can be constructed with the parameters we want to evolve:\nclass WMR:\n    def __init__(\n        self,\n        *,\n        wheel_radius: float,\n        chassis_length: float,\n        suspension_frequency: float,\n        suspension_damping: float,\n        sensor_limit: float,\n        duration: float,\n        time_step: float,\n        visualize: bool = False,\n    ):\n    ...\nIn the evolution file, we can then simulate with:\nwmr = WMR(\n    wheel_radius=wheel_radius,\n    chassis_length=chassis_length,\n    suspension_frequency=suspension_frequency,\n    suspension_damping=suspension_damping,\n    sensor_limit=sensor_limit,\n    duration=DURATION,\n    time_step=TIME_STEP,\n    visualize=visualize,\n)\nWhere each of these values is computed from a genome.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 4: Full Example"
    ]
  },
  {
    "objectID": "demos/4-full-example.html#evolution",
    "href": "demos/4-full-example.html#evolution",
    "title": "Demo 4: Full Example",
    "section": "Evolution",
    "text": "Evolution\nHere is the basic structure of the evolutionary algorithm:\n\n\n\n\n\nflowchart LR\n    Init[Initialize] --&gt; Eval[Evaluate]\n    Eval --&gt; Stop{Stop?}\n    Stop --Yes--&gt; Retn[Return]\n    Stop --No--&gt; Sele[Select]\n    Sele --&gt; Modi[Modify]\n    Modi --&gt; Evl2[Evaluate]\n    Evl2 --&gt; Comb[Combine]\n    Comb --&gt; Stop\n\n\n\n\n\n\nI like to get a bit of linting help by defining the types I’ll be using:\nGenome = list[float]\nFitness = namedtuple(\"Fitness\", [\"feasibility\", \"objective\"])\nIndividual = tuple[Genome, Fitness]\nPopulation = list[Individual]\nAnd also some utility function:\ndef clamp(lo: float, hi: float, value: float) -&gt; float: ...\ndef scale(from_lo: float, from_hi: float, to_lo: float, to_hi: float, value: float) -&gt; float: ...\ndef statistics(pop: Population) -&gt; tuple[Fitness, Fitness, Fitness]: ...\nNow the core of our algorithm’s implementation:\ndef generate_genome() -&gt; Genome: ...\ndef simulate(...) -&gt; Fitness: ...\ndef fitness(genome: Genome, testing=False) -&gt; tuple[Fitness, dict]: ...\n\ndef initialize(size: int) -&gt; Population: ...\ndef evaluate(pop: Population, manager) -&gt; Population: ...\ndef stop(pop: Population, *, _best=[Fitness(0, 0)], _counter=[0]) -&gt; bool: ...\n\ndef tournament(pop: Population) -&gt; Individual: ...\ndef select(pop: Population) -&gt; Population: ...\n\ndef mutate_gene(gene: float) -&gt; float: ...\ndef mutate(genome: Genome) -&gt; Genome: ...\ndef modify(pop: Population) -&gt; Population: ...\n\ndef combine(original: Population, children: Population) -&gt; Population: ...\nAnd here is the main loop:\npopulation = initialize(args.population_size)\npopulation = evaluate(population, manager)\n\nfor generation in range(args.num_generations):\n    if stop(population):\n        break\n\n    selected = select(population)\n    children = modify(selected)\n    children = evaluate(children, manager)\n    population = combine(population, children)\nA few of my implementation specific details are bleeding through. For example, using the enlighten progress bar manager. You can view the full code in the repository.\nHere’s a demo of the evolution script:",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 4: Full Example"
    ]
  },
  {
    "objectID": "demos/4-full-example.html#launch",
    "href": "demos/4-full-example.html#launch",
    "title": "Demo 4: Full Example",
    "section": "Launch",
    "text": "Launch\nRarely do we want to run a single “replicate” of an evolutionary optimization process. Instead, we run many with different initial conditions. The script below will launch 10 trials of the evolutionary process:\n# Load conda and activate an environment\nmodule load miniconda3\nconda activate boxcarv2\n\nPOP_SIZE=100\nNUM_GENERATIONS=100\nNUM_TRIALS=10\n\nslurm_args=\"--ntasks=1 --nodes=1 --exclusive\"\ncmd=\"python wmr_evolution.py\"\ncmd_args=\"--population_size $POP_SIZE --num_generations $NUM_GENERATIONS\"\n\nset -exuo pipefail\n\nfor trial in $(seq 1 $NUM_TRIALS); do\n    srun $slurm_args $cmd \"trial$trial\" $cmd_args --seed $trial &\ndone\nwait\nYou can find the full script with SLURM options here.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 4: Full Example"
    ]
  },
  {
    "objectID": "demos/4-full-example.html#analyze",
    "href": "demos/4-full-example.html#analyze",
    "title": "Demo 4: Full Example",
    "section": "Analyze",
    "text": "Analyze\nLast, let’s take a look at the results.\n\nVisualizations\nI like to start with the behaviors. I have my script output the “best” individual from each replicate experiment. The behavior is output as a JSON log file that I can visualize with Review (a tool I created for this purpose).\n\n&lt;p&gt;\nVisualization not shown because your browser does not allow use of an iframe.\n&lt;/p&gt;\n\nHere’s a second example with a slightly different behavior:\n\n&lt;p&gt;\nVisualization not shown because your browser does not allow use of an iframe.\n&lt;/p&gt;\n\nBoth of these are “better” behaviors than I was able to achieve by hand.\n\n\nEvolutionary Progress\nFigure Figure 1 shows the fitness of the best and average individuals over generations. We can see that the best individual from each replicate improves over time. The shaded regions denote the 95% confidence interval around the average performance.\nThe average performance (in orange) will always be a bit noisy depending on the exact algorithm. I implemented an overly simple algorithm with a lot of “exploration” and less “exploitation.”\n\n\n\n\n                                                \n\n\nFigure 1: Generations Vs. Fitness\n\n\n\n\n\n\nFinal Fitness Values\nI used the following objective function:\n\\[\nf = 2 \\left(1 - \\frac{d}{d_{\\text{max}}}\\right) + 1 \\left(1 - \\frac{\\omega}{\\omega_{\\text{max}}}\\right) + \\frac{1}{2} \\left( 1 - \\text{hit} \\right) + \\frac{1}{4} \\left(1 - \\frac{r}{r_{\\text{max}}}\\right) + \\frac{1}{4} \\left(1 - \\frac{t_r}{t_{\\text{max}}}\\right)\n\\]\nThe different components are meant to:\n\nMinimize distance from the final target location.\nMinimize the final angular velocity of the wheels.\nPenalize hitting the wall.\nMinimize the wheel radius.\nMinimize the time taken to reach rest.\n\nThis equation is pretty brittle, and with multiple objectives you would be better off using a many objective optimization algorithm, such as Lexicase.\nFrom Figure 2, we can see that we mostly achieve our goals. It appears that there is a minimum wheel radius that is able to get over the step, and we cannot instantaneously reach the target position.\n\n\n\n\n                                                \n\n\nFigure 2: Evolved Objectives of Top 5% of Final Populations\n\n\n\n\n\n\nEvolved Parameters\nNow we turn to the evolved parameters, shown in Figure 3.\n\n\n\n\n                                                \n\n\nFigure 3: Evolved Parameters of Top 5% of Final Populations\n\n\n\n\nThis plot only shows the top 5% of individuals across all final replicate populations. I filtered out the lower performing individuals since I have a heavily “exploration”-centered algorithm.\nFrom these values, we can get a good idea of our design constraints. We can also guess that it would be good to increase the maximum possible value for suspension frequency and the sensor limit. Increasing the top speed is probably not a good idea since it will be limited by the hardware more so than the other two parameters.\nFinally, in Figure 4, we take a look at the correlations among parameters.\n\n\n\n\n                                                \n\n\nFigure 4: Correlations among Evolved Parameters of Top 5% of Final Populations\n\n\n\n\nIt is usually a good idea to see if there are any strong tradeoffs among the parameters. For example, there is a strongly negative correlation between the speed slop and intercept.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 4: Full Example"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is the second occurrence of SimER. The first was as a workshop held at GECCO 2017. Here are the contributions from the workshop:\n\n20 years of reality gap: a few thoughts about simulators in evolutionary robotics by Jean-Baptiste Mouret and Konstantinos Chatzilygeroudis\nSimulating the evolution of soft and rigid-body robots by Sam Kriegman, Collin Cappelle, Francesco Corucci, Anton Bernatskiy, Nick Cheney, and Josh C. Bongard\nA baseline-realistic objective open-ended kinematics simulator for evolutionary robotics by Riley Konsella, Frank Chiarulli, John Peterson, and John Rieffel\n\nAnthony J. Clark received is Ph.D from Michigan State University. He is currently an Assistant Professor in the Computer Science Department at Pomona College in Claremont, California, USA and a Research Scientist at Caltech in Pasadena, California, USA. His research interests include autonomous robotics, control theory, adaptive control, and evolutionary optimization.\nJared M. Moore received is Ph.D from Michigan State University. He is currently an Associate Professor in the School of Computing and Information Systems at Grand Valley State University, Allendale, Michigan, USA. His research interests include adaptive software, autonomous robotics, and evolutionary optimization."
  },
  {
    "objectID": "resources/related.html",
    "href": "resources/related.html",
    "title": "Related Events",
    "section": "",
    "text": "Virtual Creatures Competition (VCC)!\nEngineering the open-ended evolution of synthetic biology\nAutomatic Design of Robot Bodies and Brains with Evolutionary Algorithms\nJAX for Scaling Up Artificial Life\nNeuroevolution\nSwissGL/GPU: tiny libraries for tiny and beautiful programs on the web",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section",
    "href": "resources/related.html#section",
    "title": "Related Events",
    "section": "",
    "text": "Virtual Creatures Competition (VCC)!\nEngineering the open-ended evolution of synthetic biology\nAutomatic Design of Robot Bodies and Brains with Evolutionary Algorithms\nJAX for Scaling Up Artificial Life\nNeuroevolution\nSwissGL/GPU: tiny libraries for tiny and beautiful programs on the web",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-1",
    "href": "resources/related.html#section-1",
    "title": "Related Events",
    "section": "2023",
    "text": "2023\n\nOpenMOLE (model exploration and validation)\nPhylogenies (how and why to track them)\nEvolving Robot Bodies and Brains in Unity\nCellular Automata\nSelf-Organizing Systems with Machine Learning",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-2",
    "href": "resources/related.html#section-2",
    "title": "Related Events",
    "section": "2022",
    "text": "2022\n\nIntroduction to Using Symbulation\nSimulating pandemics with agent-based models",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-3",
    "href": "resources/related.html#section-3",
    "title": "Related Events",
    "section": "2021",
    "text": "2021\n\nBehavioral and Cognitive Robotics, an adaptive perspective",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-4",
    "href": "resources/related.html#section-4",
    "title": "Related Events",
    "section": "2020",
    "text": "2020\n\nThe Bibites: Getting the online community involved into Alife through game development (Bibites)\nIntroduction to MABE, A tool for studying evolving systems and digital brains (MABE)\nLarge Scale Agent Based Modelling with FLAME GPU 2 (FLAME GPU 2)\nMolecular programming of swarms for ALife (MolProg)\nProgramming soft alife with SPLAT and ulam (HackSPLAT)\nVisualization Principles and Techniques for Research in ALife (ALifeVis2020)",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-5",
    "href": "resources/related.html#section-5",
    "title": "Related Events",
    "section": "2019",
    "text": "2019\n\nIntelligent Systems for Smart Cities\nIntroduction to Avida-ED",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/related.html#section-6",
    "href": "resources/related.html#section-6",
    "title": "Related Events",
    "section": "2018",
    "text": "2018\n\nAvida-ED\nCreate predictions with neural networks",
    "crumbs": [
      "Home",
      "Resources",
      "Related Events"
    ]
  },
  {
    "objectID": "resources/advice.html",
    "href": "resources/advice.html",
    "title": "Advice",
    "section": "",
    "text": "statistics (replicates)\nnoise\ndeterminism\nlevels-of-abstraction\nGNU Parallel Tutorial Pueue is a command-line task management tool",
    "crumbs": [
      "Home",
      "Resources",
      "Advice"
    ]
  },
  {
    "objectID": "resources/advice.html#mixed-environments",
    "href": "resources/advice.html#mixed-environments",
    "title": "Advice",
    "section": "Mixed Environments",
    "text": "Mixed Environments\nmixing 2d and 3d - e.g., ODE and top-down map ray tracing",
    "crumbs": [
      "Home",
      "Resources",
      "Advice"
    ]
  },
  {
    "objectID": "presentation.html#format",
    "href": "presentation.html#format",
    "title": "SimER Tutorial",
    "section": "Format",
    "text": "Format\nThis tutorial will follow a format in which:\n\nWe’ll get on the same page with respect to terminology\nLoop\n\nI’ll present for a bit\nI’ll ask you all to read through an exercise\nWe’ll have time for discussion\n\nWe’ll cover a more complete example in full",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#evolutionary-robotics",
    "href": "presentation.html#evolutionary-robotics",
    "title": "SimER Tutorial",
    "section": "Evolutionary Robotics",
    "text": "Evolutionary Robotics\nThe use of evolutionary algorithms to explore the design space of robots and their control software.",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#research-questions",
    "href": "presentation.html#research-questions",
    "title": "SimER Tutorial",
    "section": "Research Questions",
    "text": "Research Questions\nThere is a wide variety of research in evolutionary robotics, but I’ll focus on:\n\nOptimization and novelty (application-based)\nAlgorithm design (theory-based)",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#general-algorithm",
    "href": "presentation.html#general-algorithm",
    "title": "SimER Tutorial",
    "section": "General Algorithm",
    "text": "General Algorithm\n\n\n\n\n\nflowchart LR\n    Init[Initialize] --&gt; Eval[Evaluate]\n    Eval --&gt; Stop{Stop?}\n    Stop --Yes--&gt; Retn[Return]\n    Stop --No--&gt; Sele[Select]\n    Sele --&gt; Modi[Modify]\n    Modi --&gt; Evl2[Evaluate]\n    Evl2 --&gt; Comb[Combine]\n    Comb --&gt; Stop\n\n\n\n\n\n\nTODO: fix flow chart and pseudocode\npopulation = Initialize()\npopulation = Evaluate(population)\n\nLOOP\n  IF Stop(fitnesses) THEN BREAK\n  selected = Select(population)\n  children = Modify(selected)\n  children = Evaluate(children)\n  population = Combine(population, children)\n\nRETURN population\npopulation = initialize(POPULATION_SIZE)\npopulation = evaluate(population)\n\nfor generation in range(NUM_GENERATIONS):\n    if stop(population):\n        break\n\n    # Tournament selection\n    selected = select(population)\n    # Just mutation (no crossover?); maybe DE?\n    children = modify(selected)\n    children = evaluate(children)\n    # Elitism of 1?\n    population = combine(population, children)\n\nFitness = tuple[float, float]\nGenome = list[float]\nIndividual = tuple[Genome, Fitness]\nPopulation = list[Individual]\n\ndef initialize(size: int) -&gt; Population: ...\ndef evaluate(pop: Population) -&gt; Population: ...\ndef stop(pop: Population) -&gt; bool: ...\ndef select(pop: Population) -&gt; Population: ...\ndef modify(pop: Population) -&gt; Population: ...\ndef combine(pop1: Population, pop2: Population) -&gt; Population: ...",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#practical-considerations-1",
    "href": "presentation.html#practical-considerations-1",
    "title": "SimER Tutorial",
    "section": "Practical Considerations",
    "text": "Practical Considerations\n\nSimulation, feasibility, and reality gap\nComputational resources (headless, parallelism, etc.)\nManagement (analysis, visualizing, plotting, etc.)\nResearch management (tracking, reproducibility, collaboration, etc.)\nValidation on hardware\n\nMajor challenge: “reality gap”",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#simulation",
    "href": "presentation.html#simulation",
    "title": "SimER Tutorial",
    "section": "Simulation",
    "text": "Simulation\n\nFollow a gradient of feasibility to provide a better “gradient”\nScale your parameters for numerical stability\n…",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#parallelism",
    "href": "presentation.html#parallelism",
    "title": "SimER Tutorial",
    "section": "Parallelism",
    "text": "Parallelism\nYou’ll want to run your experiments on a compute cluster if possible.\n\nParallelize replicate experiments (different random seeds)\nParallelize across generations (if mixing populations)\nParallelize across populations (multiple population per replicate)\nParallelize across individuals (multiple individuals per population)\nParallelize across trials (multiple trials per individual)",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#parallelism-advice",
    "href": "presentation.html#parallelism-advice",
    "title": "SimER Tutorial",
    "section": "Parallelism Advice",
    "text": "Parallelism Advice\n\nPlan to use \\(N - 2\\) cores, where \\(N\\) is the number of cores available\nUse a tool like GNU Parallel at the replicate level\nUse a library like Python multiprocessing at lower levels\nConsider what you need to evaluate for early stopping when making your choices between higher and lower levels of parallelism\n\nDo you care more about the variance across replicates? Parallelize at the replicate level\nDo you care more about the performance of a single replicate? Parallelize at the individual level",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#experiment-management",
    "href": "presentation.html#experiment-management",
    "title": "SimER Tutorial",
    "section": "Experiment Management",
    "text": "Experiment Management\n\nwandb, for example",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#problem-statement",
    "href": "presentation.html#problem-statement",
    "title": "SimER Tutorial",
    "section": "Problem Statement",
    "text": "Problem Statement\nObjective: maximize the distance traveled by an autonomous wheeled mobile robot (WMR) in a fixed amount of time.",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#online-demos",
    "href": "presentation.html#online-demos",
    "title": "SimER Tutorial",
    "section": "Online Demos",
    "text": "Online Demos\nStarting with Analytical Models",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "presentation.html#full-examples",
    "href": "presentation.html#full-examples",
    "title": "SimER Tutorial",
    "section": "Full Examples",
    "text": "Full Examples\nFull description at Full Example",
    "crumbs": [
      "Home",
      "Presentation",
      "SimER Tutorial"
    ]
  },
  {
    "objectID": "resources/tools.html",
    "href": "resources/tools.html",
    "title": "Tools",
    "section": "",
    "text": "Simulation plays a vital role in optimization and in understanding evolutionary dynamics. SimER focuses on rigid-body dynamics, but we’ve listed a few related ideas below as well.\nCreating a simulation is called “modeling.” In robotics, modeling is used for simulation, state estimation, prediction, and model-based algorithms (e.g., model predictive control, model-based reinforcement learning).\nBroadly, we can list the following forms of simulation as it relates to evolutionary robotics (ER)\nOften, an increase in accuracy comes at the cost of an increase in complexity and compute time. Analytical simulations are often only useful for toy problems (i.e., they are not even expressive enough to simulate a double pendulum system). Numerical systems are much broader—in some sense, they encapsulate rigid-body and soft-body dynamics—but they are often slower and less powerful compared to rigid-body and soft-body simulators. For example, a nonholonomic system cannot be described by a closed-form solution. In this case, a numerical or physical simulation is required.\nHere are things to consider when selecting your simulation tool:",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#robot-simulators",
    "href": "resources/tools.html#robot-simulators",
    "title": "Tools",
    "section": "Robot Simulators",
    "text": "Robot Simulators\n\nGazebo\nCoppeliaSim (V-REP replacement)\nWebots\nIsaac Sim\nVortex Studio\nDrake\nRoboDK\nMARS\nSimscape Multibody\nRaiSim",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#game-engines",
    "href": "resources/tools.html#game-engines",
    "title": "Tools",
    "section": "Game Engines",
    "text": "Game Engines\n\nUnreal Engine\nUnity\nGodot Engine\nBevy",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#physics-engines",
    "href": "resources/tools.html#physics-engines",
    "title": "Tools",
    "section": "Physics Engines",
    "text": "Physics Engines\n\nGame focused\n\nPhysX\nBullet\nODE\nJolt Physics\nHavok\nNewton Dynamics\nReactPhysics3D\n\nResearch/Robotics focused\n\nMuJoCo\nPROJECTCHRONO\nDART\nTPE (Trivial Physics Engine)\nRBDL\nRigidBodyDynamics.jl\nRapier",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#numerical-engines",
    "href": "resources/tools.html#numerical-engines",
    "title": "Tools",
    "section": "Numerical Engines",
    "text": "Numerical Engines\n\nGNU Octave\nSageMath\nScilab\nSimPy\nMATLAB\nWolfram Mathematica\nMaple\nDynamicalSystems.jl",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#soft-body-engines",
    "href": "resources/tools.html#soft-body-engines",
    "title": "Tools",
    "section": "Soft-Body Engines",
    "text": "Soft-Body Engines\n\nSoft Robotics Toolkit\nVoxCad\nevosoro: soft robot simulator\nDiffAqua",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#rendering-engines",
    "href": "resources/tools.html#rendering-engines",
    "title": "Tools",
    "section": "Rendering Engines",
    "text": "Rendering Engines\n\nOGRE\nIrrlicht Engine\nbgfx\nFilament\nMagnum Engine\nThree.js",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#configuration-language",
    "href": "resources/tools.html#configuration-language",
    "title": "Tools",
    "section": "Configuration Language",
    "text": "Configuration Language\n\nURDF (and Xacro)\nSDFormat\nSKEL\nCOLLADA\nSMURF\nSRDF",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#authoring-tools",
    "href": "resources/tools.html#authoring-tools",
    "title": "Tools",
    "section": "Authoring Tools",
    "text": "Authoring Tools\n\nPhobos\nOnshape-to-robot\nSolidWorks to URDF Exporter",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "resources/tools.html#physics-engine-development",
    "href": "resources/tools.html#physics-engine-development",
    "title": "Tools",
    "section": "Physics Engine Development",
    "text": "Physics Engine Development\n\nIntegration Basics\nFix Your Timestep!\nTen Minute Physics\nBox2D-Lite",
    "crumbs": [
      "Home",
      "Resources",
      "Tools"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SimER Tutorial",
    "section": "",
    "text": "ALIFE has a long history with virtual creatures, and the Virtual Creatures Competition (VCC) has been a mainstay at the conference for a decade now. Enabling research in this area are many unique, and often single-purpose, simulation environments. The variety of simulation options is useful for creating finely tuned experiments but makes it difficult for newcomers to the field to determine which simulation environment is appropriate for their particular problem.\nALIFE has also hosted several tutorials relating to this work, for example,\nThis tutorial, will provide a broader look at the paradigms and tools used in the field of evolutionary robotics (and in ALIFE more generally). Specifically, we will discuss the use of several different simulation methods and tools, including:\nWe will also discuss visualization techniques.\nOf course, covering this wide range of topics necessarily means that we will not be able to go into great depth on all of them. Instead we will pay special attention to the use of physical simulation engines as they provide the widest range of possibilities with respect to creating and evolving virtual creatures. Staying with the theme of ALIFE 2024 we will share our experiences with “weird and wacky” results (and how to avoid them if they are not what you are looking for)."
  },
  {
    "objectID": "index.html#tutorial-agenda",
    "href": "index.html#tutorial-agenda",
    "title": "SimER Tutorial",
    "section": "Tutorial Agenda",
    "text": "Tutorial Agenda\n\nPresentation\nTutorial Demos\nExploration"
  },
  {
    "objectID": "index.html#logistics",
    "href": "index.html#logistics",
    "title": "SimER Tutorial",
    "section": "Logistics",
    "text": "Logistics\n\nFriday, 26 July\nParallel session 10: 15:00 - 16:40\nRoom: TBD\nQuestion and Answers: TBD (Google Sheet)"
  },
  {
    "objectID": "index.html#audience",
    "href": "index.html#audience",
    "title": "SimER Tutorial",
    "section": "Audience",
    "text": "Audience\nOur primary target audience members are researchers new to the field of ALIFE and evolutionary robotics. We are also happy to have more experienced researchers looking for information to share with their students."
  },
  {
    "objectID": "demos/3-rigid-body-dynamics.html",
    "href": "demos/3-rigid-body-dynamics.html",
    "title": "Demo 3: Rigid Body Models",
    "section": "",
    "text": "Let’s revisit our problem statement:\nAt this point, we can still not handle complex obstacles. A rigid body dynamics engine will enable us to do so.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 3: Rigid Body Models"
    ]
  },
  {
    "objectID": "demos/3-rigid-body-dynamics.html#rigid-body-dynamics",
    "href": "demos/3-rigid-body-dynamics.html#rigid-body-dynamics",
    "title": "Demo 3: Rigid Body Models",
    "section": "Rigid Body Dynamics",
    "text": "Rigid Body Dynamics\nThe example below uses Planck.js to simulate our WMR. This is a 2D physics engine (meant for games) that can fully simulate our scenario. Planck.js is a Javascript/Typescript library based on a commonly used C/C++ physics engine called Box2D.\n\n    \n\n\nimport { Player } from '../_lib/Player/dist/player.js';\nimport { WMRSimulator, WMR2DMode } from  '../_lib/WMR2D/dist/wmr2d.js';\n\nuiTimeEnd = 16.0;\nuiTimeStep = 0.1;\n\nwmr1 = new WMRSimulator( 'wmr-canvas1', WMR2DMode.RBDEngine );\nplayer1 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr1.step(time), () =&gt; wmr1.reset() );\nplayer1.create();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou might notice that the WMR “jolts” a bit when it hits the wall. This is a nice benefit of using the physics engine—it does a better job of simulating the contact between the robot and the wall. This simulation also adds a suspension to the interface between the wheels and the chassis. This will be easier to see in the next animation.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 3: Rigid Body Models"
    ]
  },
  {
    "objectID": "demos/3-rigid-body-dynamics.html#creating-a-more-realistic-wmr",
    "href": "demos/3-rigid-body-dynamics.html#creating-a-more-realistic-wmr",
    "title": "Demo 3: Rigid Body Models",
    "section": "Creating a More Realistic WMR",
    "text": "Creating a More Realistic WMR\nUsing a physics engine takes some work, but it completely pays off. In general, one must:\n\nCreate a dynamics “world” and collision space.\nCreate static bodies and geometries (e.g., walls).\nCreate dynamic bodies and geometries (e.g., the robot).\nAdd constraints and joints (e.g., connecting wheels to the chassis).\nContinually “step” the simulation and apply external forces (e.g., motor torque).\n\nHere are each of those steps using Planck.js and our WMR:\n// 1. Create a dynamics \"world\" and collision space.\n\nworld = new World( { gravity: new Vec2( 0.0, - 9.8 ) } );\n\n// 2. Create static bodies and geometries (e.g., walls).\n\nconst groundFriction = 0.7;\nground = world.createBody( { type: 'static', position: new Vec2( 0.0, 0.0 ) } );\nground.createFixture( { shape: new Edge( new Vec2( - 100, 0 ), new Vec2( 100, 0 ) ), friction: groundFriction } );\n\nconst wallPositionVec = new Vec2( simWidth * 0.9, 0.0 );\nwall = world.createBody( { type: 'static', position: wallPositionVec } );\nwall.createFixture( { shape: new Box( wallThickness / 2.0, 2.0 ) } );\n\n// 3. Create dynamic bodies and geometries (e.g., the robot).\n\nconst materialDensity = 0.7;\nconst materialFriction = 0.3;\n\nchassis = world.createBody( { type: 'dynamic', position: initialPosition } );\nchassis.createFixture( { shape: new Box( chassisLength / 2, chassisHeight / 2 ), density: materialDensity, friction: materialFriction } );\n\nwheelFront = world.createBody( { type: 'dynamic', position: wheelPositionFront } );\nwheelFront.createFixture( { shape: new Circle( wheelRadius ), density: materialDensity, friction: materialFriction } );\n\nwheelRear = world.createBody( { type: 'dynamic', position: wheelPositionRear } );\nwheelRear.createFixture( { shape: new Circle( wheelRadius ), density: materialDensity, friction: materialFriction } );\n\n// 4. Add constraints and joints (e.g., connecting wheels to the chassis).\n\nconst motorMaxTorque = 20.0;\nconst suspensionHz = 4.0;\nconst suspensionDampingRatio = 0.7;\n\nwheelMotorFront = world.createJoint( new WheelJoint( {\n    motorSpeed: 0.0,\n    enableMotor: true,\n    maxMotorTorque: motorMaxTorque,\n    frequencyHz: suspensionHz,\n    dampingRatio: suspensionDampingRatio,\n}, chassis, wheelFront, wheelFront.getPosition(), new Vec2( 0.0, 1.0 ) ) )!;\n\nwheelMotorRear = world.createJoint( new WheelJoint( {\n    motorSpeed: 0.0,\n    enableMotor: true,\n    maxMotorTorque: motorMaxTorque,\n    frequencyHz: suspensionHz,\n    dampingRatio: suspensionDampingRatio,\n}, chassis, wheelRear, wheelRear.getPosition(), new Vec2( 0.0, 1.0 ) ) )!;\n\nwheelMotorFront.setMotorSpeed( - angularVelocity );\nwheelMotorRear.setMotorSpeed( - angularVelocity );\n\n// 5. Continually \"step\" the simulation and apply external forces (e.g., motor torque).\n\nfunction simulateStep( frameTime: number ) {\n\n    timeAccumulator += frameTime;\n\n    while ( timeAccumulator &gt;= timeStep ) {\n\n        world.step( this.timeStep, velocityIterations, positionIterations );\n        timeAccumulator -= timeStep;\n        time += timeStep;\n\n        if ( time &gt;= controlLastUpdate ) {\n\n            const dist = getDistanceToWall();\n            angularVelocity = Math.max( - speedMax, Math.min( speedMax, speedSlope * dist + speedIntercept ) );\n\n            controlLastUpdate += controlPeriod;\n\n        }\n\n    }\n\n}\n\nwhile ( !done ) {\n\n    frameTime = getFrameTime();\n    simulateStep( frameTime );\n    render();\n\n}\nThat might look a bit intimidating, but it is really just the same objects getting created for each rigid body. You’ll create something that reacts to forces (rigid bodies) and collision objects (fixtures) so that the physics engine can simulate the interactions among them.\nHere is some of the terminology used by common physics engines:\n\n\n\nEngine\nWorld\nBody\nShape\nJoint\n\n\n\n\nPlanck.js\nWorld\nBody\nShape\nJoint\n\n\nBox2D\nWorld\nBody\nShape\nJoint\n\n\nODE\nWorld+Space\nBody\nGeom\nJoint\n\n\nPROJECTCHRONO\nSystem\nBody\nShape\nLink\n\n\nDART\nWorld\nSkeleton+Shape\nShape\nJoint\n\n\nBullet\nWorld\nBody\nShape\nJoint\n\n\nurdf*\nWorld\nLink\nGeometry\nJoint\n\n\n\n*URDF is technically a file format, but it is used by several physics engines to describe the robot’s structure and dynamics.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 3: Rigid Body Models"
    ]
  },
  {
    "objectID": "demos/3-rigid-body-dynamics.html#adding-a-small-obstacle",
    "href": "demos/3-rigid-body-dynamics.html#adding-a-small-obstacle",
    "title": "Demo 3: Rigid Body Models",
    "section": "Adding a Small Obstacle",
    "text": "Adding a Small Obstacle\nHere is now our full example simulation.\n\n    \n\n\nwmr2 = new WMRSimulator( 'wmr-canvas2', WMR2DMode.RBDEngine, { addWall: true, addStep: true} );\nplayer2 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr2.step(time), () =&gt; wmr2.reset() );\nplayer2.create();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere is the full source code for the demo.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 3: Rigid Body Models"
    ]
  },
  {
    "objectID": "demos/3-rigid-body-dynamics.html#optimizing-our-wmr",
    "href": "demos/3-rigid-body-dynamics.html#optimizing-our-wmr",
    "title": "Demo 3: Rigid Body Models",
    "section": "Optimizing our WMR",
    "text": "Optimizing our WMR\nRevisiting our problem statement:\n\nWe want to evolve an autonomous wheeled mobile robot (WMR) to navigator quickly over obstacles and then stop in front of a wall.\n\nWe just now need some way to optimize our WMR. Let’s start by listing the evolvable parameters:\n\n\n\n\n\n\nEvolvable Parameters\n\n\n\n\n\nThis is not an exhaustive list, but it is a good starting point:\n\nWheel radius\nChassis length\nSuspension parameters\nSensor parameters\nControl parameters\n\n\n\n\nIn the final demo, we will explore how to optimize these parameters using a genetic algorithm.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 3: Rigid Body Models"
    ]
  },
  {
    "objectID": "demos/2-numerical.html",
    "href": "demos/2-numerical.html",
    "title": "Demo 2: Numerical Models",
    "section": "",
    "text": "Let’s revisit our problem statement:\nWith an analytical model, we can simulate the position of the WMR, but we did not attempt to handle obstacles and we learned that dynamic control was not possible.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 2: Numerical Models"
    ]
  },
  {
    "objectID": "demos/2-numerical.html#dynamic-control",
    "href": "demos/2-numerical.html#dynamic-control",
    "title": "Demo 2: Numerical Models",
    "section": "Dynamic Control",
    "text": "Dynamic Control\nAlthough the numerical simulation requires more computational resources to compute the position, it enables us to handle obstacles and dynamic control. Here is the simulation with a wall in front of the WMR and the following controller:\n\\[\n\\omega = \\max( -\\Omega, \\min( \\Omega, m d + b)\n\\tag{3}\\]\n\n    \n\n\nwmr2 = new WMRSimulator( 'wmr-canvas2', WMR2DMode.Numerical, { addWall: true } );\nplayer2 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr2.step(time), () =&gt; wmr2.reset() );\nplayer2.create();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnd here is the corresponding code snippet:\ninitialPosition = 0;\nchassisPosition = initialPosition;\n\nangularVelocity = 1;\nwheelRadius = 1;\n\nwheelChassisOffset = 1;\nwheelPositionFront = wheelChassisOffset;\nwheelPositionRear = -wheelChassisOffset;\n\nwheelAngleFront = 0;\nwheelAngleRear = 0;\n\ntimeAccumulator = 0;\ntimeStep = 0.01;\ntime = 0;\n\nspeedMax = 3;\nspeedSlope = 2;\nspeedIntercept = -8;\n\ncontrolPeriod = 0.1;\ncontrolLastUpdate = 0;\n\nfunction simulateStep( frameTime: number ) {\n\n    timeAccumulator += frameTime;\n\n    while ( timeAccumulator &gt;= timeStep ) {\n\n        // p = v t = ω r t\n        chassisPosition += angularVelocity * wheelRadius * timeStep;\n\n        wheelAngleFront += angularVelocity * timeStep;\n        wheelAngleRear += angularVelocity * timeStep;\n\n        timeAccumulator -= timeStep;\n        time += timeStep;\n\n        if ( time &gt;= controlLastUpdate ) {\n\n            const dist = getDistanceToWall();\n            angularVelocity = Math.max( - speedMax, Math.min( speedMax, speedSlope * dist + speedIntercept ) );\n\n            controlLastUpdate += controlPeriod;\n\n        }\n\n    }\n\n    wheelPositionFront = chassisPosition + wheelChassisOffset;\n    wheelPositionRear = chassisPosition - wheelChassisOffset;\n\n}\n\nwhile ( !done ) {\n\n    frameTime = getFrameTime();\n    simulateStep( frameTime );\n    render();\n\n}\nHere are some key points to note:\n\nWe can no longer compute the position of the robot for any time \\(t\\) without knowing the previous position.\nWe’ve decoupled simulation and visualization (rendering).\nWe’ve set a fixed time step, which is better for numerical stability.\nIn this simple example, we only need to update the wheel positions once per render time. This is not a general case, but a simplification that we can take since the wheels are not independent of the chassis.\n\nRead Fix Your Timestep! for more information on this code structure.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 2: Numerical Models"
    ]
  },
  {
    "objectID": "demos/2-numerical.html#adding-complex-collisions-and-dynamics",
    "href": "demos/2-numerical.html#adding-complex-collisions-and-dynamics",
    "title": "Demo 2: Numerical Models",
    "section": "Adding Complex Collisions and Dynamics",
    "text": "Adding Complex Collisions and Dynamics\nHow could we change our code if we:\n\nAdded an incline to the ground plane?\nAdded a second wall in front of the robot?\nAdded a step in front of the robot?\n\nAlthough these changes seem similar, (1) and (3) are quite a bit harder to implement. Why?\n\n\n\n\n\n\nComplex Collisions and Dynamics\n\n\n\n\n\nChanging the incline will require us to move to a more advanced method for integration. The code above implements a simple Euler integration, which works perfectly well for constant velocity dynamics (constant between time steps).\nAdding a step requires us to change the orientations of all objects, implement more complex collision detection, and implement a friction model.\nAdding a second wall is as simple as the first wall.\n\n\n\n\n    \n\n\nwmr3 = new WMRSimulator( 'wmr-canvas3', WMR2DMode.Numerical, { addWall: true, addStep: true } );\nplayer3 = new Player( uiTimeEnd, uiTimeStep, (time) =&gt; wmr3.step(time), () =&gt; wmr3.reset() );\nplayer3.create();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis simple numerical simulation does not work with a step. In the next demo we will explore how to handle complex collisions and dynamics.",
    "crumbs": [
      "Home",
      "Demos",
      "Demo 2: Numerical Models"
    ]
  }
]